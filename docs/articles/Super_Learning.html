<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Combined Dynamic Predictions via Super Learning ‚Ä¢ JMbayes2</title>
<!-- favicons --><link rel="icon" type="image/png" sizes="96x96" href="../favicon-96x96.png">
<link rel="icon" type="‚Äùimage/svg+xml‚Äù" href="../favicon.svg">
<link rel="apple-touch-icon" sizes="180x180" href="../apple-touch-icon.png">
<link rel="icon" sizes="any" href="../favicon.ico">
<link rel="manifest" href="../site.webmanifest">
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Combined Dynamic Predictions via Super Learning">
<meta name="robots" content="noindex">
<!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=G-YDBZ5DBBSP"></script><script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-YDBZ5DBBSP');
</script>
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-primary" data-bs-theme="dark" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">JMbayes2</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.5-9</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../articles/JMbayes2.html">Get started</a></li>
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/Baseline_Hazard.html">Baseline Hazard Function</a></li>
    <li><a class="dropdown-item" href="../articles/Causal_Effects.html">Causal Effects</a></li>
    <li><a class="dropdown-item" href="../articles/Competing_Risks.html">Competing Risks</a></li>
    <li><a class="dropdown-item" href="../articles/Dynamic_Predictions.html">Dynamic Predictions</a></li>
    <li><a class="dropdown-item" href="../articles/Multi_State_Processes.html">Multi-State Processes</a></li>
    <li><a class="dropdown-item" href="../articles/Non_Gaussian_Mixed_Models.html">Non-Gaussian Mixed Models</a></li>
    <li><a class="dropdown-item" href="../articles/Recurring_Events.html">Recurrent Events</a></li>
    <li><a class="dropdown-item" href="../articles/Super_Learning.html">Combined Dynamic Predictions via Super Learning</a></li>
    <li><a class="dropdown-item" href="../articles/Time_Varying_Effects.html">Time Varying Effects</a></li>
    <li><a class="dropdown-item" href="../articles/Transformation_Functions.html">Transformation Functions for Functional Forms</a></li>
  </ul>
</li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/drizopoulos/JMbayes2/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../logo.png" class="logo" alt=""><h1>Combined Dynamic Predictions via Super Learning</h1>
                        <h4 data-toc-skip class="author">Dimitris
Rizopoulos</h4>
            
            <h4 data-toc-skip class="date">2025-07-18</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/drizopoulos/JMbayes2/blob/HEAD/vignettes/Super_Learning.Rmd" class="external-link"><code>vignettes/Super_Learning.Rmd</code></a></small>
      <div class="d-none name"><code>Super_Learning.Rmd</code></div>
    </div>

    
    
<div class="section level2">
<h2 id="super-learning">Super Learning<a class="anchor" aria-label="anchor" href="#super-learning"></a>
</h2>
<div class="section level3">
<h3 id="motivation-and-theory">Motivation and Theory<a class="anchor" aria-label="anchor" href="#motivation-and-theory"></a>
</h3>
<p>Joint models for longitudinal and time-to-event data have been
established as a versatile tool for calculating dynamic predictions for
longitudinal and survival outcomes. The advantageous feature of these
predictions is that they are updated over time as extra information
becomes available. As a result, they have found numerous applications in
precision medicine, including cancer and cardiovascular diseases.
Previous applications of joint models have considered a single model for
obtaining dynamic predictions. However, finding a well-specified model
can be challenging, especially considering multiple longitudinal
outcomes. Moreover, due to the dynamic nature of these predictions,
different models may provide different levels of accuracy at different
follow-up times. Here, we consider multiple joint models instead and
combine the dynamic predictions from these models to optimize the
predictive accuracy. We use the concept of super learning (SL) to
achieve this. SL is an ensemble method that allows researchers to
combine several different prediction algorithms into one. It uses
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>V</mi><annotation encoding="application/x-tex">V</annotation></semantics></math>-fold
cross-validation to build the optimally weighted combination of
predictions from a library of candidate algorithms. Optimality is
defined by a user-specified objective function, such as minimizing mean
squared error or maximizing the area under the receiver operating
characteristic curve.</p>
<p>The basic idea behind super learning is to derive model weights that
optimize the cross-validated predictions. More specifically, we let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>‚Ñí</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><msub><mi>M</mi><mn>1</mn></msub><mo>,</mo><mi>‚Ä¶</mi><mo>,</mo><msub><mi>M</mi><mi>L</mi></msub><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\mathcal{L} = \{M_1, \ldots, M_L\}</annotation></semantics></math>
denote a library with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>
models. There are no restrictions to the models included in this
library, and it is recommended to consider a wide range of possible
models. Among others, these joint models differ in the specification of
the time trend in the longitudinal submodels and the functions form and
event submodel. We split the original dataset
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ùíü</mi><mi>n</mi></msub><annotation encoding="application/x-tex">\mathcal{D}_n</annotation></semantics></math>
in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>V</mi><annotation encoding="application/x-tex">V</annotation></semantics></math>
folds. The choice of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>V</mi><annotation encoding="application/x-tex">V</annotation></semantics></math>
will depend on the size and number of events in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ùíü</mi><mi>n</mi></msub><annotation encoding="application/x-tex">\mathcal{D}_n</annotation></semantics></math>.
In particular, for each fold, we need to have a sufficient number of
events to quantify the predictive performance robustly. Using the
cross-validation method, we fit the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>
models in the combined
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo>‚àí</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">v-1</annotation></semantics></math>
folds, and we will calculate predictions for the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>v</mi><annotation encoding="application/x-tex">v</annotation></semantics></math>-th
fold we left outside. Due to the dynamic nature of the predictions, we
want to derive optimal weights at different follow-up times. More
specifically, we consider the sequence of time points
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub><mo>,</mo><mi>‚Ä¶</mi><mo>,</mo><msub><mi>t</mi><mi>Q</mi></msub></mrow><annotation encoding="application/x-tex">t_1, \ldots, t_Q</annotation></semantics></math>.
The number and placing of these time points should again consider the
available event information in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ùíü</mi><mi>n</mi></msub><annotation encoding="application/x-tex">\mathcal{D}_n</annotation></semantics></math>.
For
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>q</mi></msub><mo>‚àà</mo><mo stretchy="false" form="prefix">{</mo><msub><mi>t</mi><mn>1</mn></msub><mo>,</mo><mi>‚Ä¶</mi><mo>,</mo><msub><mi>t</mi><mi>Q</mi></msub><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">t_q \in \{t_1, \ldots, t_Q\}</annotation></semantics></math>,
we define
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>‚Ñõ</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>t</mi><mi>q</mi></msub><mo>,</mo><mi>v</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathcal{R}(t_q, v)</annotation></semantics></math>
to denote the subjects at risk at time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>t</mi><mi>q</mi></msub><annotation encoding="application/x-tex">t_q</annotation></semantics></math>
that belong to the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>v</mi><annotation encoding="application/x-tex">v</annotation></semantics></math>-th
fold. For all subjects in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>‚Ñõ</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>t</mi><mi>q</mi></msub><mo>,</mo><mi>v</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathcal{R}(t_q, v)</annotation></semantics></math>,
we calculate the cross-validated predictions,
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mover><mi>œÄ</mi><mo accent="true">ÃÇ</mo></mover><mi>i</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>v</mi><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>t</mi><mi>q</mi></msub><mo>+</mo><mi>Œî</mi><mi>t</mi><mo>‚à£</mo><msub><mi>t</mi><mi>q</mi></msub><mo>,</mo><msub><mi>M</mi><mi>l</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mo>Pr</mo><mo stretchy="false" form="prefix">{</mo><msubsup><mi>T</mi><mi>i</mi><mo>*</mo></msubsup><mo>&lt;</mo><msub><mi>t</mi><mi>q</mi></msub><mo>+</mo><mi>Œî</mi><mi>t</mi><mo>‚à£</mo><msubsup><mi>T</mi><mi>i</mi><mo>*</mo></msubsup><mo>&gt;</mo><msub><mi>t</mi><mi>q</mi></msub><mo>,</mo><msub><mi>‚Ñã</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><msub><mi>M</mi><mi>l</mi></msub><mo>,</mo><msubsup><mi>ùíü</mi><mi>n</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>‚àí</mi><mi>v</mi><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><mo stretchy="false" form="postfix">}</mo><mi>.</mi></mrow><annotation encoding="application/x-tex">\hat{\pi}_i^{(v)}(t_q + \Delta t \mid t_q, M_l) = \Pr \{T_i^* &lt; t_q + \Delta t \mid T_i^* &gt; t_q, \mathcal H_i(t), M_l, \mathcal{D}_n^{(-v)}\}.</annotation></semantics></math>
These predictions are calculated based on model
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>M</mi><mi>l</mi></msub><annotation encoding="application/x-tex">M_l</annotation></semantics></math>
in library
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>‚Ñí</mi><annotation encoding="application/x-tex">\mathcal{L}</annotation></semantics></math>
that was fitted in the dataset
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>ùíü</mi><mi>n</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>‚àí</mi><mi>v</mi><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><annotation encoding="application/x-tex">\mathcal{D}_n^{(-v)}</annotation></semantics></math>
the excludes the patients in the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>v</mi><annotation encoding="application/x-tex">v</annotation></semantics></math>-th
fold. The calculation is based on a Monte Carlo approach. We define
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mover><mover><mi>œÄ</mi><mo accent="true">ÃÉ</mo></mover><mo accent="true">ÃÇ</mo></mover><mi>i</mi><mi>v</mi></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>t</mi><mi>q</mi></msub><mo>+</mo><mi>Œî</mi><mi>t</mi><mo>‚à£</mo><msub><mi>t</mi><mi>q</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat{\tilde{\pi}}_i^{v}(t_q + \Delta t \mid t_q)</annotation></semantics></math>
to denote the convex combination of the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>
predictions, i.e.,
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mover><mover><mi>œÄ</mi><mo accent="true">ÃÉ</mo></mover><mo accent="true">ÃÇ</mo></mover><mi>i</mi><mi>v</mi></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>t</mi><mi>q</mi></msub><mo>+</mo><mi>Œî</mi><mi>t</mi><mo>‚à£</mo><msub><mi>t</mi><mi>q</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><munderover><mo>‚àë</mo><mrow><mi>l</mi><mo>=</mo><mn>1</mn></mrow><mi>L</mi></munderover><msub><mo>œñ</mo><mi>l</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>t</mi><mi>q</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><msubsup><mover><mi>œÄ</mi><mo accent="true">ÃÇ</mo></mover><mi>i</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>v</mi><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>t</mi><mi>q</mi></msub><mo>+</mo><mi>Œî</mi><mi>t</mi><mo>‚à£</mo><msub><mi>t</mi><mi>q</mi></msub><mo>,</mo><msub><mi>M</mi><mi>l</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mspace width="1.0em"></mspace><mrow><mtext mathvariant="normal">for all </mtext><mspace width="0.333em"></mspace></mrow><mi>v</mi><mo>‚àà</mo><mrow><mn>1</mn><mo>,</mo><mi>‚Ä¶</mi><mo>,</mo><mi>V</mi></mrow><mo>,</mo></mrow><annotation encoding="application/x-tex">\hat{\tilde{\pi}}_i^{v}(t_q + \Delta t \mid t_q) = \sum\limits_{l = 1}^L \varpi_l(t_q) \hat{\pi}_i^{(v)}(t_q + \Delta t \mid t_q, M_l), \quad \mbox{for all } v \in {1, \ldots, V},</annotation></semantics></math>
with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>œñ</mo><mi>l</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>t</mi><mi>q</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\varpi_l(t_q) &gt; 0</annotation></semantics></math>,
for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>‚Ä¶</mi><mo>,</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">l = 1, \ldots, L</annotation></semantics></math>,
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>‚àë</mo><mi>l</mi></msub><msub><mo>œñ</mo><mi>l</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>t</mi><mi>q</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\sum_l \varpi_l(t_q) = 1</annotation></semantics></math>.
Note that the weights
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>œñ</mo><mi>l</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>‚ãÖ</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\varpi_l(\cdot)</annotation></semantics></math>
are time-varying, i.e., at different follow-up times, different
combinations of the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>
models may yield more accurate predictions.</p>
<p>For any time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>,
we will select the weights
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><msub><mo>œñ</mo><mi>l</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>;</mo><mi>l</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>‚Ä¶</mi><mo>,</mo><mi>L</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\{\varpi_l(t); l = 1, \ldots, L\}</annotation></semantics></math>
that optimize the predictive performance of the combined cross-validated
predictions using proper scoring rules. A scoring rule
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ùíÆ</mi><mo stretchy="false" form="prefix">{</mo><msub><mi>œÄ</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>u</mi><mo>‚à£</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mi>ùïÄ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo>&lt;</mo><msubsup><mi>T</mi><mi>i</mi><mo>*</mo></msubsup><mo>&lt;</mo><mi>u</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\mathcal{S}\{\pi_i(u \mid t), \mathbb{I}(t &lt; T_i^* &lt; u)\}</annotation></semantics></math>
is called proper if the true distribution achieves the optimal expected
score, i.e., in our case if
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mrow><mo stretchy="true" form="prefix">[</mo><mi>ùíÆ</mi><mo stretchy="false" form="prefix">{</mo><msubsup><mi>œÄ</mi><mi>i</mi><mrow><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi></mrow></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mi>u</mi><mo>‚à£</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mspace width="0.278em"></mspace><mi>ùïÄ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo>&lt;</mo><msubsup><mi>T</mi><mi>i</mi><mo>*</mo></msubsup><mo>&lt;</mo><mi>u</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="false" form="postfix">}</mo><mo stretchy="true" form="postfix">]</mo></mrow><mo>‚â§</mo><mi>E</mi><mrow><mo stretchy="true" form="prefix">[</mo><mi>ùíÆ</mi><mo stretchy="false" form="prefix">{</mo><msub><mover><mi>œÄ</mi><mo accent="true">ÃÇ</mo></mover><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>u</mi><mo>‚à£</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mspace width="0.278em"></mspace><mi>ùïÄ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo>&lt;</mo><msubsup><mi>T</mi><mi>i</mi><mo>*</mo></msubsup><mo>&lt;</mo><mi>u</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="false" form="postfix">}</mo><mo stretchy="true" form="postfix">]</mo></mrow><mo>,</mo><mspace width="1.0em"></mspace><mi>u</mi><mo>&gt;</mo><mi>t</mi><mo>,</mo></mrow><annotation encoding="application/x-tex">E \left [\mathcal{S}\{\pi_i^{true}(u \mid t), \; \mathbb{I}(t &lt; T_i^* &lt; u) \} \right] \leq E \left [\mathcal{S}\{\hat{\pi}_i(u \mid t), \; \mathbb{I}(t &lt; T_i^* &lt; u) \} \right], \quad u &gt; t,</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>œÄ</mi><mi>i</mi><mrow><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi></mrow></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mi>u</mi><mo>‚à£</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\pi_i^{true}(u \mid t)</annotation></semantics></math>
denotes the conditional risk probabilities under the true model, and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>œÄ</mi><mo accent="true">ÃÇ</mo></mover><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>u</mi><mo>‚à£</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat{\pi}_i(u \mid t)</annotation></semantics></math>
is an estimate of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>œÄ</mi><mi>i</mi><mrow><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi></mrow></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mi>u</mi><mo>‚à£</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\pi_i^{true}(u \mid t)</annotation></semantics></math>.
The expectation is taken with respect to the conditional density of the
survival outcome under the true model
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><msubsup><mi>T</mi><mi>i</mi><mo>*</mo></msubsup><mo>‚à£</mo><msubsup><mi>T</mi><mi>i</mi><mo>*</mo></msubsup><mo>&gt;</mo><mi>t</mi><mo>,</mo><msub><mi>ùí¥</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\{T_i^* \mid T_i^* &gt; t, \mathcal Y_i(t)\}</annotation></semantics></math>,
with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ùí¥</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mo stretchy="false" form="prefix">{</mo><msub><mi>y</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>t</mi><mrow><mi>i</mi><mi>l</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>;</mo><mn>0</mn><mo>‚â§</mo><msub><mi>t</mi><mrow><mi>i</mi><mi>l</mi></mrow></msub><mo>‚â§</mo><mi>t</mi><mo>,</mo><mi>l</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>‚Ä¶</mi><mo>,</mo><msub><mi>n</mi><mi>i</mi></msub><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\mathcal Y_i(t) = \{ y_i(t_{il}); 0 \leq t_{il} \leq t, l = 1, \ldots, n_i\}</annotation></semantics></math>,
and the scoring rule
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ùíÆ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>‚ãÖ</mi><mo>,</mo><mi>‚ãÖ</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathcal S(\cdot, \cdot)</annotation></semantics></math>
is defined such that a lower score indicates better accuracy.</p>
<p>The Brier score is a proper scoring rule that combines discrimination
and calibration to measure overall predictive performance. In
particular, at follow-up time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
and for a medically-relevant time window
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Œî</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">\Delta t</annotation></semantics></math>,
we define the Brier score as
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">BS</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo>+</mo><mi>Œî</mi><mi>t</mi><mo>,</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>E</mi><mrow><mo stretchy="true" form="prefix">[</mo><msup><mrow><mo stretchy="true" form="prefix">{</mo><mi>ùïÄ</mi><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>T</mi><mi>i</mi><mo>*</mo></msubsup><mo>‚â§</mo><mi>t</mi><mo>+</mo><mi>Œî</mi><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>‚àí</mo><msubsup><mover><mi>œÄ</mi><mo accent="true">ÃÉ</mo></mover><mi>i</mi><mi>v</mi></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo>+</mo><mi>Œî</mi><mi>t</mi><mo>‚à£</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">}</mo></mrow><mn>2</mn></msup><mspace width="0.278em"></mspace><mo minsize="1.8" maxsize="1.8" stretchy="false" form="prefix">|</mo><mspace width="0.278em"></mspace><msubsup><mi>T</mi><mi>i</mi><mo>*</mo></msubsup><mo>&gt;</mo><mi>t</mi><mo stretchy="true" form="postfix">]</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">\mbox{BS}(t + \Delta t, t) = E \left [\left \{ \mathbb{I}(T_i^* \leq t + \Delta t) - \tilde{\pi}_i^{v}(t + \Delta t \mid t) \right \}^2 \; \Big | \; T_i^* &gt; t \right].</annotation></semantics></math></p>
<p>As an alternative proper scoring rule in the interval
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo>,</mo><mi>t</mi><mo>+</mo><mi>Œî</mi><mi>t</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">(t, t + \Delta t]</annotation></semantics></math>
we consider an adaptation of the expected predictive cross-entropy
(EPCE):
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">EPCE</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo>+</mo><mi>Œî</mi><mi>t</mi><mo>,</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>E</mi><mrow><mo stretchy="true" form="prefix">{</mo><mi>‚àí</mi><mo>log</mo><mrow><mo stretchy="true" form="prefix">[</mo><mi>p</mi><mo minsize="1.2" maxsize="1.2" stretchy="false" form="prefix">{</mo><msubsup><mi>T</mi><mi>i</mi><mo>*</mo></msubsup><mo>‚à£</mo><mi>t</mi><mo>&lt;</mo><msubsup><mi>T</mi><mi>i</mi><mo>*</mo></msubsup><mo>&lt;</mo><mi>t</mi><mo>+</mo><mi>Œî</mi><mi>t</mi><mo>,</mo><msub><mi>ùí¥</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><msub><mi>ùíü</mi><mi>n</mi></msub><mo minsize="1.2" maxsize="1.2" stretchy="false" form="postfix">}</mo><mo stretchy="true" form="postfix">]</mo></mrow><mo stretchy="true" form="postfix">}</mo></mrow><mo>,</mo></mrow><annotation encoding="application/x-tex">\mbox{EPCE}(t + \Delta t, t) = E \left \{-\log \left [ p \bigl \{ T_i^* \mid t &lt; T_i^* &lt; t + \Delta t, \mathcal Y_i(t), \mathcal D_{n} \bigr \} \right ] \right \},</annotation></semantics></math></p>
<p>where the expectation is taken with respect to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><msubsup><mi>T</mi><mi>i</mi><mo>*</mo></msubsup><mo>‚à£</mo><msubsup><mi>T</mi><mi>i</mi><mo>*</mo></msubsup><mo>&gt;</mo><mi>t</mi><mo>,</mo><msub><mi>ùí¥</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\{T_i^* \mid T_i^* &gt; t, \mathcal Y_i(t)\}</annotation></semantics></math>
under the true model. In our context, both
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">BS</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo>+</mo><mi>Œî</mi><mi>t</mi><mo>,</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mbox{BS}(t + \Delta t, t)</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">EPCE</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo>+</mo><mi>Œî</mi><mi>t</mi><mo>,</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mbox{EPCE}(t + \Delta t, t)</annotation></semantics></math>
are calculated using the convex combination of the cross-validated
predictions
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mover><mover><mi>œÄ</mi><mo accent="true">ÃÉ</mo></mover><mo accent="true">ÃÇ</mo></mover><mi>i</mi><mi>v</mi></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo>+</mo><mi>Œî</mi><mi>t</mi><mo>‚à£</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat{\tilde{\pi}}_i^{v}(t + \Delta t \mid t)</annotation></semantics></math>.
In particular, using the super-learning procedure, we obtain the weights
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mo>œñ</mo><mo accent="true">ÃÇ</mo></mover><mi>l</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\widehat{\varpi}_l(t)</annotation></semantics></math>
that minimize a proper scoring rule (in our case, either the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">BS</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo>+</mo><mi>Œî</mi><mi>t</mi><mo>,</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mbox{BS}(t + \Delta t, t)</annotation></semantics></math>
or
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">EPCE</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo>+</mo><mi>Œî</mi><mi>t</mi><mo>,</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mbox{EPCE}(t + \Delta t, t)</annotation></semantics></math>)
of the cross-validated predictions,
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mo>œñ</mo><mo accent="true">ÃÇ</mo></mover><mi>l</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mtext mathvariant="normal">argmin</mtext><mo>œñ</mo></msub><mrow><mo stretchy="true" form="prefix">[</mo><mi>ùíÆ</mi><mrow><mo stretchy="true" form="prefix">{</mo><munderover><mo>‚àë</mo><mrow><mi>l</mi><mo>=</mo><mn>1</mn></mrow><mi>L</mi></munderover><msub><mo>œñ</mo><mi>l</mi></msub><msubsup><mover><mi>œÄ</mi><mo accent="true">ÃÇ</mo></mover><mi>i</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>v</mi><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo>+</mo><mi>Œî</mi><mi>t</mi><mo>‚à£</mo><mi>t</mi><mo>,</mo><msub><mi>M</mi><mi>l</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><msub><mi>T</mi><mi>i</mi></msub><mo>,</mo><msub><mi>Œ¥</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">}</mo></mrow><mo stretchy="true" form="postfix">]</mo></mrow><mo>,</mo><mspace width="1.0em"></mspace><mi>v</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>‚Ä¶</mi><mo>,</mo><mi>V</mi><mo>,</mo></mrow><annotation encoding="application/x-tex">\widehat{\varpi}_l(t) = \mbox{argmin}_{\varpi} \left [ \mathcal{S} \left \{ \sum_{l = 1}^L \varpi_l \hat{\pi}_i^{(v)}(t + \Delta t \mid t, M_l), T_i, \delta_i \right \} \right], \quad v = 1, \ldots, V,</annotation></semantics></math></p>
<p>under the constraints
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>œñ</mo><mi>l</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\varpi_l(t) &gt; 0</annotation></semantics></math>,
for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>‚Ä¶</mi><mo>,</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">l = 1, \ldots, L</annotation></semantics></math>,
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>‚àë</mo><mi>l</mi></msub><msub><mo>œñ</mo><mi>l</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\sum_l \varpi_l(t) = 1</annotation></semantics></math>.</p>
</div>
<div class="section level3">
<h3 id="example">Example<a class="anchor" aria-label="anchor" href="#example"></a>
</h3>
<p>We will illustrate the application of super learning for combining
dynamic predictions from joint models using the PBC dataset. We start by
splitting the <code>pbc2</code> database into five folds using function
<code><a href="../reference/accuracy.html">create_folds()</a></code>:</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">CVdats</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/accuracy.html">create_folds</a></span><span class="op">(</span><span class="va">pbc2</span>, V <span class="op">=</span> <span class="fl">5</span>, id_var <span class="op">=</span> <span class="st">"id"</span><span class="op">)</span></span></code></pre></div>
<p>The first argument for this function is the <code>data.frame</code>
we wish to split in <code>V</code> folds. The argument
<code>id_var</code> specifies the name of the subject‚Äôs id variable in
this dataset. The output of <code><a href="../reference/accuracy.html">create_folds()</a></code> is a list with
two components named <code>"training"</code> and <code>"testing"</code>.
Each component is another list with <code>V</code> data.frames.</p>
<p>Next, we define the function that will fit the joint models we wish
to consider for calculating predictions. This function should have as a
single argument a <code>data.frame</code> that will be used to fit the
joint models. To optimize computational performance we will use parallel
computing to fit these models to the different training datasets. Hence,
within the function we should have the call
<code><a href="https://drizopoulos.github.io/JMbayes2/">library("JMbayes2")</a></code> to load package
<strong>JMbayes2</strong> for each worker. The output of this function
should be a list of the fitted joint models with class
<code>"jmList"</code>. Assigning this class to the resulting list will
facilitate combining the predictions later. For our example, we use the
following specifications:</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">fit_models</span> <span class="op">&lt;-</span> <span class="kw">function</span> <span class="op">(</span><span class="va">data</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="st"><a href="https://drizopoulos.github.io/JMbayes2/">"JMbayes2"</a></span><span class="op">)</span></span>
<span>    <span class="va">data</span><span class="op">$</span><span class="va">status2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/numeric.html" class="external-link">as.numeric</a></span><span class="op">(</span><span class="va">data</span><span class="op">$</span><span class="va">status</span> <span class="op">!=</span> <span class="st">"alive"</span><span class="op">)</span></span>
<span>    <span class="va">data_id</span> <span class="op">&lt;-</span> <span class="va">data</span><span class="op">[</span><span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/duplicated.html" class="external-link">duplicated</a></span><span class="op">(</span><span class="va">data</span><span class="op">$</span><span class="va">id</span><span class="op">)</span>, <span class="op">]</span></span>
<span>    <span class="va">lmeFit</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/nlme/man/lme.html" class="external-link">lme</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="va">serBilir</span><span class="op">)</span> <span class="op">~</span> <span class="va">year</span>, data <span class="op">=</span> <span class="va">data</span>,</span>
<span>                  random <span class="op">=</span> <span class="op">~</span> <span class="va">year</span> <span class="op">|</span> <span class="va">id</span>,</span>
<span>                  control <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/pkg/nlme/man/lmeControl.html" class="external-link">lmeControl</a></span><span class="op">(</span>opt <span class="op">=</span> <span class="st">"optim"</span><span class="op">)</span><span class="op">)</span></span>
<span>    <span class="va">CoxFit</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/survival/man/coxph.html" class="external-link">coxph</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/pkg/survival/man/Surv.html" class="external-link">Surv</a></span><span class="op">(</span><span class="va">years</span>, <span class="va">status2</span><span class="op">)</span> <span class="op">~</span> <span class="fl">1</span>, data <span class="op">=</span> <span class="va">data_id</span><span class="op">)</span></span>
<span>    <span class="va">jmFit1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/jm.html">jm</a></span><span class="op">(</span><span class="va">CoxFit</span>, <span class="va">lmeFit</span>, time_var <span class="op">=</span> <span class="st">"year"</span><span class="op">)</span></span>
<span>    <span class="va">jmFit2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/update.html" class="external-link">update</a></span><span class="op">(</span><span class="va">jmFit1</span>, </span>
<span>                     functional_forms <span class="op">=</span> <span class="op">~</span> <span class="fu"><a href="../reference/jm.html">slope</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="va">serBilir</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span>    <span class="va">jmFit3</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/update.html" class="external-link">update</a></span><span class="op">(</span><span class="va">jmFit1</span>, </span>
<span>                     functional_forms <span class="op">=</span> <span class="op">~</span> <span class="fu"><a href="../reference/jm.html">value</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="va">serBilir</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span> <span class="fu"><a href="../reference/jm.html">area</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="va">serBilir</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span>    <span class="co">###</span></span>
<span>    <span class="va">lmeFit2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/nlme/man/lme.html" class="external-link">lme</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="va">serBilir</span><span class="op">)</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/r/splines/ns.html" class="external-link">ns</a></span><span class="op">(</span><span class="va">year</span>, <span class="fl">2</span>, B <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">14.4</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span> <span class="va">sex</span> <span class="op">+</span> <span class="va">age</span>, </span>
<span>                   data <span class="op">=</span> <span class="va">data</span>, random <span class="op">=</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/r/splines/ns.html" class="external-link">ns</a></span><span class="op">(</span><span class="va">year</span>, <span class="fl">2</span>, B <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">14.4</span><span class="op">)</span><span class="op">)</span> <span class="op">|</span> <span class="va">id</span>,</span>
<span>                   control <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/pkg/nlme/man/lmeControl.html" class="external-link">lmeControl</a></span><span class="op">(</span>opt <span class="op">=</span> <span class="st">"optim"</span><span class="op">)</span><span class="op">)</span></span>
<span>    <span class="va">CoxFit2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/survival/man/coxph.html" class="external-link">coxph</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/pkg/survival/man/Surv.html" class="external-link">Surv</a></span><span class="op">(</span><span class="va">years</span>, <span class="va">status2</span><span class="op">)</span> <span class="op">~</span> <span class="va">sex</span> <span class="op">+</span> <span class="va">age</span>, data <span class="op">=</span> <span class="va">data_id</span><span class="op">)</span></span>
<span>    <span class="va">jmFit4</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/jm.html">jm</a></span><span class="op">(</span><span class="va">CoxFit2</span>, <span class="va">lmeFit2</span>, time_var <span class="op">=</span> <span class="st">"year"</span><span class="op">)</span></span>
<span>    <span class="va">jmFit5</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/update.html" class="external-link">update</a></span><span class="op">(</span><span class="va">jmFit4</span>, </span>
<span>                     functional_forms <span class="op">=</span> <span class="op">~</span> <span class="fu"><a href="../reference/jm.html">slope</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="va">serBilir</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span>    <span class="va">out</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>M1 <span class="op">=</span> <span class="va">jmFit1</span>, M2 <span class="op">=</span> <span class="va">jmFit2</span>, M3 <span class="op">=</span> <span class="va">jmFit3</span>, M4 <span class="op">=</span> <span class="va">jmFit4</span>, M5 <span class="op">=</span> <span class="va">jmFit5</span><span class="op">)</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/class.html" class="external-link">class</a></span><span class="op">(</span><span class="va">out</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="st">"jmList"</span></span>
<span>    <span class="va">out</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>In particular, we consider a library of univariate joint models for
the longitudinal outcome <code>serBilir</code> and the composite event
transplantation or death. The first three models consider a simple
linear mixed effects model for serum bilirubin with random intercepts
and random slopes per subject and no other covariates. Also, in the Cox
model for the composite event, we do not specify any baseline
covariates; hence, the risk of the composite event depends only on serum
bilirubin. The three models differ in the corresponding functional
forms, i.e., the current value of log serum bilirubin, the current
slope/velocity of log serum bilirubin, and the current value plus the
area under the log serum bilirubin trajectory. The last models consider
a more elaborate specification of the linear mixed model that includes
natural cubic splines in both the fixed and random effects to allow for
non-linearities in the log serum bilirubin trajectories and the main
effects of sex and age in both the mixed and Cox models. The functional
forms are, again, the current value and the current slope.</p>
<p>We fit these models in the training datasets using parallel computing
as facilitated using the <strong>parallel</strong> package
(<em>note</em>: this and the subsequent computations require some time
to perform depending on your machine; in my machine with an Intel(R)
Core(TM) i9-10885H CPU @ 2.40GHz and 32.0 GB RAM takes about 20 min to
run the whole vignette):</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">cl</span> <span class="op">&lt;-</span> <span class="fu">parallel</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/r/parallel/makeCluster.html" class="external-link">makeCluster</a></span><span class="op">(</span><span class="fl">5L</span><span class="op">)</span></span>
<span><span class="va">Models_folds</span> <span class="op">&lt;-</span> <span class="fu">parallel</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/r/parallel/clusterApply.html" class="external-link">parLapply</a></span><span class="op">(</span><span class="va">cl</span>, <span class="va">CVdats</span><span class="op">$</span><span class="va">training</span>, <span class="va">fit_models</span><span class="op">)</span></span>
<span><span class="fu">parallel</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/r/parallel/makeCluster.html" class="external-link">stopCluster</a></span><span class="op">(</span><span class="va">cl</span><span class="op">)</span></span></code></pre></div>
<p>We calculate the weights to combine the predictions from these five
models to optimize the integrated Brier score and the expected
predictive cross-entropy at follow-up time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">t = 6</annotation></semantics></math>
years and for a relevant window of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Œî</mi><mi>t</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">\Delta t = 2</annotation></semantics></math>
years. The function <code><a href="../reference/accuracy.html">tvBrier()</a></code> automatically performs this
task by providing the list of joint models fitted in the training
datasets as a first argument. The integrated Brier score is calculated
using the testing datasets that are provided in the <code>newdata</code>
argument:</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">tstr</span> <span class="op">&lt;-</span> <span class="fl">6</span></span>
<span><span class="va">thor</span> <span class="op">&lt;-</span> <span class="fl">8</span></span>
<span></span>
<span><span class="va">Brier_weights</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/accuracy.html">tvBrier</a></span><span class="op">(</span><span class="va">Models_folds</span>, newdata <span class="op">=</span> <span class="va">CVdats</span><span class="op">$</span><span class="va">testing</span>, </span>
<span>                         integrated <span class="op">=</span> <span class="cn">TRUE</span>, Tstart <span class="op">=</span> <span class="va">tstr</span>, Thoriz <span class="op">=</span> <span class="va">thor</span><span class="op">)</span></span>
<span><span class="va">Brier_weights</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Cross-Validated Prediction Error using the Library of Joint Models 'Models_folds'</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Super Learning Estimated Integrated Brier score: 0.0548</span></span>
<span><span class="co">#&gt; In the time interval: [6, 8)</span></span>
<span><span class="co">#&gt; For the 166 subjects at risk at time 6</span></span>
<span><span class="co">#&gt; Number of subjects with an event in [6, 8): 18</span></span>
<span><span class="co">#&gt; Number of subjects with a censored time in [6, 8): 44</span></span>
<span><span class="co">#&gt; Accounting for censoring using model-based weights</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Integrated Brier score per model: 0.0596 0.0588 0.0613 0.0523 0.0611</span></span>
<span><span class="co">#&gt; Weights per model: 0.199 0.1976 0.1925 0.214 0.1969</span></span>
<span><span class="co">#&gt; Number of folds: 5</span></span></code></pre></div>
<p>We observe that the fourth model dominates the weights. Hence, the
integrated Brier score based on the combined predictions is essentially
the integrated Brier score of this model. To calculate the model weights
using the expected predictive cross-entropy, use function
<code><a href="../reference/accuracy.html">tvEPCE()</a></code> with an almost identical call as for the Brier
score:</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">EPCE_weights</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/accuracy.html">tvEPCE</a></span><span class="op">(</span><span class="va">Models_folds</span>, newdata <span class="op">=</span> <span class="va">CVdats</span><span class="op">$</span><span class="va">testing</span>, </span>
<span>                       Tstart <span class="op">=</span> <span class="va">tstr</span>, Thoriz <span class="op">=</span> <span class="va">thor</span><span class="op">)</span></span>
<span><span class="va">EPCE_weights</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Cross-Validated Expected Predictive Cross-Entropy using the Library of Joint Models 'Models_folds'</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Super Learning Estimated EPCE: 0.3109</span></span>
<span><span class="co">#&gt; In the time interval: [6, 8)</span></span>
<span><span class="co">#&gt; For the 166 subjects at risk at time 6</span></span>
<span><span class="co">#&gt; Number of subjects with an event in [6, 8): 18</span></span>
<span><span class="co">#&gt; Number of subjects with a censored time in [6, 8): 44</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; EPCE per model: 0.3568 0.3599 0.3639 0.3589 0.4157</span></span>
<span><span class="co">#&gt; Weights per model: 0.0013 0.5387 0.4599 0 1e-04</span></span>
<span><span class="co">#&gt; Number of folds: 5</span></span></code></pre></div>
<p>The EPCE results indicate that models <code>M2</code> and
<code>M3</code> share the most weight. We observe that the EPCE based on
the combined cross-validated predictions is smaller than the EPCE based
on the cross-validated predictions of each individual model.</p>
<p>To use these weights in practice, we must first refit the five joint
models we considered in the original dataset.</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">Models</span> <span class="op">&lt;-</span> <span class="fu">fit_models</span><span class="op">(</span><span class="va">pbc2</span><span class="op">)</span></span></code></pre></div>
<p>Then, we construct the dataset with the subjects at risk at year six
and consider the longitudinal measurements collected before this
follow-up time. Also, we set in this dataset the observed event time to
six and the event variable to zero, i.e., indicating that patients were
event-free up to this time:</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">ND</span> <span class="op">&lt;-</span> <span class="va">pbc2</span><span class="op">[</span><span class="va">pbc2</span><span class="op">$</span><span class="va">years</span> <span class="op">&gt;</span> <span class="va">tstr</span> <span class="op">&amp;</span> <span class="va">pbc2</span><span class="op">$</span><span class="va">year</span> <span class="op">&lt;=</span> <span class="va">tstr</span>, <span class="op">]</span></span>
<span><span class="va">ND</span><span class="op">$</span><span class="va">id</span> <span class="op">&lt;-</span> <span class="va">ND</span><span class="op">$</span><span class="va">id</span><span class="op">[</span>, drop <span class="op">=</span> <span class="cn">TRUE</span><span class="op">]</span></span>
<span><span class="va">ND</span><span class="op">$</span><span class="va">years</span> <span class="op">&lt;-</span> <span class="va">tstr</span></span>
<span><span class="va">ND</span><span class="op">$</span><span class="va">status2</span> <span class="op">&lt;-</span> <span class="fl">0</span></span></code></pre></div>
<p>As an illustration, we will combine the cumulative risk predictions
for Patient 8 using the EPCE weights. We achieve that using the
<code><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict()</a></code> method for objects of class
<code>"jmList"</code>; we also need to provide the <code>weights</code>
argument. The rest of the arguments are the same as in the
<code><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict()</a></code> method for <code>"jm"</code> objects (see also
the Dynamic Predictions vignette):</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">model_weights</span> <span class="op">&lt;-</span> <span class="va">EPCE_weights</span><span class="op">$</span><span class="va">weights</span></span>
<span></span>
<span><span class="va">predsEvent</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict</a></span><span class="op">(</span><span class="va">Models</span>, weights <span class="op">=</span> <span class="va">model_weights</span>, newdata <span class="op">=</span> <span class="va">ND</span><span class="op">[</span><span class="va">ND</span><span class="op">$</span><span class="va">id</span> <span class="op">==</span> <span class="fl">8</span>, <span class="op">]</span>,</span>
<span>                      process <span class="op">=</span> <span class="st">"event"</span>, return_newdata <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="va">predsLong</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict</a></span><span class="op">(</span><span class="va">Models</span>, weights <span class="op">=</span> <span class="va">model_weights</span>, newdata <span class="op">=</span> <span class="va">ND</span><span class="op">[</span><span class="va">ND</span><span class="op">$</span><span class="va">id</span> <span class="op">==</span> <span class="fl">8</span>, <span class="op">]</span>,</span>
<span>                     return_newdata <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">predsLong</span>, <span class="va">predsEvent</span><span class="op">)</span></span></code></pre></div>
<p><img src="Super_Learning_files/figure-html/unnamed-chunk-1-1.png" width="816" style="display: block; margin: auto;"></p>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by <a href="https://www.drizopoulos.com/" class="external-link">Dimitris Rizopoulos</a>, <a href="https://pafonso.com/" class="external-link">Pedro Miranda Afonso</a>, <a href="https://gregpapageorgiou.com/" class="external-link">Grigorios Papageorgiou</a>.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.3.</p>
</div>

    </footer>
</div>





  </body>
</html>
